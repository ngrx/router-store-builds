{
  "version": 3,
  "sources": ["../../../../modules/router-store/src/actions.ts", "../../../../modules/router-store/src/reducer.ts", "../../../../modules/router-store/src/serializers/minimal_serializer.ts", "../../../../modules/router-store/src/router_store_config.ts", "../../../../modules/router-store/src/serializers/full_serializer.ts", "../../../../modules/router-store/src/serializers/base.ts", "../../../../modules/router-store/src/store_router_connecting.service.ts", "../../../../modules/router-store/src/provide_router_store.ts", "../../../../modules/router-store/src/router_store_module.ts", "../../../../modules/router-store/src/router_selectors.ts"],
  "sourcesContent": ["import {\n  NavigationCancel,\n  NavigationEnd,\n  NavigationError,\n  NavigationStart,\n  RoutesRecognized,\n} from '@angular/router';\n\nimport { BaseRouterStoreState } from './serializers/base';\nimport { SerializedRouterStateSnapshot } from './serializers/full_serializer';\nimport { createAction, props } from '@ngrx/store';\n\n/**\n * An action dispatched when a router navigation request is fired.\n */\nexport const ROUTER_REQUEST = '@ngrx/router-store/request';\n\n/**\n * Payload of ROUTER_REQUEST\n */\nexport type RouterRequestPayload<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: T;\n  event: NavigationStart;\n};\n\n/**\n * An action dispatched when a router navigation request is fired.\n */\nexport type RouterRequestAction<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_REQUEST;\n  payload: RouterRequestPayload<T>;\n};\n\nexport const routerRequestAction = createAction(\n  ROUTER_REQUEST,\n  props<{ payload: RouterRequestPayload<SerializedRouterStateSnapshot> }>()\n);\n/**\n * An action dispatched when the router navigates.\n */\nexport const ROUTER_NAVIGATION = '@ngrx/router-store/navigation';\n\n/**\n * Payload of ROUTER_NAVIGATION.\n */\nexport type RouterNavigationPayload<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: T;\n  event: RoutesRecognized;\n};\n\n/**\n * An action dispatched when the router navigates.\n */\nexport type RouterNavigationAction<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_NAVIGATION;\n  payload: RouterNavigationPayload<T>;\n};\n\nexport const routerNavigationAction = createAction(\n  ROUTER_NAVIGATION,\n  props<{ payload: RouterNavigationPayload<SerializedRouterStateSnapshot> }>()\n);\n\n/**\n * An action dispatched when the router cancels navigation.\n */\nexport const ROUTER_CANCEL = '@ngrx/router-store/cancel';\n\n/**\n * Payload of ROUTER_CANCEL.\n */\nexport type RouterCancelPayload<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: V;\n  storeState: T;\n  event: NavigationCancel;\n};\n\n/**\n * An action dispatched when the router cancels navigation.\n */\nexport type RouterCancelAction<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_CANCEL;\n  payload: RouterCancelPayload<T, V>;\n};\n\nexport const routerCancelAction = createAction(\n  ROUTER_CANCEL,\n  props<{ payload: RouterCancelPayload<SerializedRouterStateSnapshot> }>()\n);\n\n/**\n * An action dispatched when the router errors.\n */\nexport const ROUTER_ERROR = '@ngrx/router-store/error';\n\n/**\n * Payload of ROUTER_ERROR.\n */\nexport type RouterErrorPayload<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: V;\n  storeState: T;\n  event: NavigationError;\n};\n\n/**\n * An action dispatched when the router errors.\n */\nexport type RouterErrorAction<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_ERROR;\n  payload: RouterErrorPayload<T, V>;\n};\n\nexport const routerErrorAction = createAction(\n  ROUTER_ERROR,\n  props<{ payload: RouterErrorPayload<SerializedRouterStateSnapshot> }>()\n);\n\n/**\n * An action dispatched after navigation has ended and new route is active.\n */\nexport const ROUTER_NAVIGATED = '@ngrx/router-store/navigated';\n\n/**\n * Payload of ROUTER_NAVIGATED.\n */\nexport type RouterNavigatedPayload<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: T;\n  event: NavigationEnd;\n};\n\n/**\n * An action dispatched after navigation has ended and new route is active.\n */\nexport type RouterNavigatedAction<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_NAVIGATED;\n  payload: RouterNavigatedPayload<T>;\n};\n\nexport const routerNavigatedAction = createAction(\n  ROUTER_NAVIGATED,\n  props<{ payload: RouterNavigatedPayload<SerializedRouterStateSnapshot> }>()\n);\n\n/**\n * A union type of router actions.\n */\nexport type RouterAction<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> =\n  | RouterRequestAction<V>\n  | RouterNavigationAction<V>\n  | RouterCancelAction<T, V>\n  | RouterErrorAction<T, V>\n  | RouterNavigatedAction<V>;\n", "import { Action } from '@ngrx/store';\nimport {\n  ROUTER_CANCEL,\n  ROUTER_ERROR,\n  ROUTER_NAVIGATION,\n  RouterAction,\n} from './actions';\nimport { BaseRouterStoreState } from './serializers/base';\nimport { SerializedRouterStateSnapshot } from './serializers/full_serializer';\n\nexport type RouterReducerState<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  state: T;\n  navigationId: number;\n};\n\nexport function routerReducer<\n  RouterState extends BaseRouterStoreState = SerializedRouterStateSnapshot,\n  Result = RouterReducerState<RouterState>\n>(state: Result | undefined, action: Action): Result {\n  // Allow compilation with strictFunctionTypes - ref: #1344\n  const routerAction = action as RouterAction<any, RouterState>;\n  switch (routerAction.type) {\n    case ROUTER_NAVIGATION:\n    case ROUTER_ERROR:\n    case ROUTER_CANCEL:\n      return {\n        state: routerAction.payload.routerState,\n        navigationId: routerAction.payload.event.id,\n      } as unknown as Result;\n    default:\n      return state as Result;\n  }\n}\n", "import { ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\nimport { BaseRouterStoreState, RouterStateSerializer } from './base';\n\nexport interface MinimalActivatedRouteSnapshot {\n  routeConfig: ActivatedRouteSnapshot['routeConfig'];\n  url: ActivatedRouteSnapshot['url'];\n  params: ActivatedRouteSnapshot['params'];\n  queryParams: ActivatedRouteSnapshot['queryParams'];\n  fragment: ActivatedRouteSnapshot['fragment'];\n  data: ActivatedRouteSnapshot['data'];\n  outlet: ActivatedRouteSnapshot['outlet'];\n  title: ActivatedRouteSnapshot['title'];\n  firstChild?: MinimalActivatedRouteSnapshot;\n  children: MinimalActivatedRouteSnapshot[];\n}\n\nexport interface MinimalRouterStateSnapshot extends BaseRouterStoreState {\n  root: MinimalActivatedRouteSnapshot;\n  url: string;\n}\n\nexport class MinimalRouterStateSerializer\n  implements RouterStateSerializer<MinimalRouterStateSnapshot>\n{\n  serialize(routerState: RouterStateSnapshot): MinimalRouterStateSnapshot {\n    return {\n      root: this.serializeRoute(routerState.root),\n      url: routerState.url,\n    };\n  }\n\n  private serializeRoute(\n    route: ActivatedRouteSnapshot\n  ): MinimalActivatedRouteSnapshot {\n    const children = route.children.map((c) => this.serializeRoute(c));\n    return {\n      params: route.params,\n      data: route.data,\n      url: route.url,\n      outlet: route.outlet,\n      title: route.title,\n      routeConfig: route.routeConfig\n        ? {\n            path: route.routeConfig.path,\n            pathMatch: route.routeConfig.pathMatch,\n            redirectTo: route.routeConfig.redirectTo,\n            outlet: route.routeConfig.outlet,\n            title:\n              typeof route.routeConfig.title === 'string'\n                ? route.routeConfig.title\n                : undefined,\n          }\n        : null,\n      queryParams: route.queryParams,\n      fragment: route.fragment,\n      firstChild: children[0],\n      children,\n    };\n  }\n}\n", "import { InjectionToken } from '@angular/core';\nimport { Selector } from '@ngrx/store';\nimport { RouterReducerState } from './reducer';\nimport {\n  BaseRouterStoreState,\n  RouterStateSerializer,\n} from './serializers/base';\nimport { SerializedRouterStateSnapshot } from './serializers/full_serializer';\nimport { MinimalRouterStateSerializer } from './serializers/minimal_serializer';\n\nexport type StateKeyOrSelector<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = string | Selector<any, RouterReducerState<T>>;\n\nexport enum NavigationActionTiming {\n  PreActivation = 1,\n  PostActivation = 2,\n}\nexport const DEFAULT_ROUTER_FEATURENAME = 'router';\n\nexport const _ROUTER_CONFIG = new InjectionToken(\n  '@ngrx/router-store Internal Configuration'\n);\nexport const ROUTER_CONFIG = new InjectionToken(\n  '@ngrx/router-store Configuration'\n);\n\n/**\n * Minimal = Serializes the router event with MinimalRouterStateSerializer\n * Full = Serializes the router event with FullRouterStateSerializer\n */\nexport const enum RouterState {\n  Full,\n  Minimal,\n}\n\nexport function _createRouterConfig(\n  config: StoreRouterConfig\n): StoreRouterConfig {\n  return {\n    stateKey: DEFAULT_ROUTER_FEATURENAME,\n    serializer: MinimalRouterStateSerializer,\n    navigationActionTiming: NavigationActionTiming.PreActivation,\n    ...config,\n  };\n}\n\nexport interface StoreRouterConfig<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> {\n  stateKey?: StateKeyOrSelector<T>;\n  serializer?: new (...args: any[]) => RouterStateSerializer;\n  /**\n   * By default, ROUTER_NAVIGATION is dispatched before guards and resolvers run.\n   * Therefore, the action could run too soon, for example\n   * there may be a navigation cancel due to a guard saying the navigation is not allowed.\n   * To run ROUTER_NAVIGATION after guards and resolvers,\n   * set this property to NavigationActionTiming.PostActivation.\n   */\n  navigationActionTiming?: NavigationActionTiming;\n  /**\n   * Decides which router serializer should be used, if there is none provided, and the metadata on the dispatched @ngrx/router-store action payload.\n   * Set to `Minimal` to use the `MinimalRouterStateSerializer` and to set a minimal router event with the navigation id and url as payload.\n   * Set to `Full` to use the `FullRouterStateSerializer` and to set the angular router events as payload.\n   */\n  routerState?: RouterState;\n}\n", "import { ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\nimport { BaseRouterStoreState, RouterStateSerializer } from './base';\n\nexport interface SerializedRouterStateSnapshot extends BaseRouterStoreState {\n  root: ActivatedRouteSnapshot;\n  url: string;\n}\n\nexport class FullRouterStateSerializer\n  implements RouterStateSerializer<SerializedRouterStateSnapshot>\n{\n  serialize(routerState: RouterStateSnapshot): SerializedRouterStateSnapshot {\n    return {\n      root: this.serializeRoute(routerState.root),\n      url: routerState.url,\n    };\n  }\n\n  private serializeRoute(\n    route: ActivatedRouteSnapshot\n  ): ActivatedRouteSnapshot {\n    const children = route.children.map((c) => this.serializeRoute(c));\n    return {\n      params: route.params,\n      paramMap: route.paramMap,\n      data: route.data,\n      url: route.url,\n      outlet: route.outlet,\n      title: route.title,\n      routeConfig: route.routeConfig\n        ? {\n            component: route.routeConfig.component,\n            path: route.routeConfig.path,\n            pathMatch: route.routeConfig.pathMatch,\n            redirectTo: route.routeConfig.redirectTo,\n            outlet: route.routeConfig.outlet,\n            title: route.routeConfig.title,\n          }\n        : null,\n      queryParams: route.queryParams,\n      queryParamMap: route.queryParamMap,\n      fragment: route.fragment,\n      component: (route.routeConfig\n        ? route.routeConfig.component\n        : undefined) as any,\n      root: undefined as any,\n      parent: undefined as any,\n      firstChild: children[0],\n      pathFromRoot: undefined as any,\n      children,\n    };\n  }\n}\n", "import { RouterStateSnapshot } from '@angular/router';\n\n/**\n * Simple router state.\n * All custom router states / state serializers should have at least\n * the properties of this interface.\n */\nexport interface BaseRouterStoreState {\n  url: string;\n}\n\nexport abstract class RouterStateSerializer<\n  T extends BaseRouterStoreState = BaseRouterStoreState\n> {\n  abstract serialize(routerState: RouterStateSnapshot): T;\n}\n", "import { ErrorHandler, Inject, Injectable, isDevMode } from '@angular/core';\nimport {\n  Event,\n  NavigationCancel,\n  NavigationEnd,\n  NavigationError,\n  NavigationStart,\n  Router,\n  RouterEvent,\n  RoutesRecognized,\n} from '@angular/router';\nimport {\n  ACTIVE_RUNTIME_CHECKS,\n  isNgrxMockEnvironment,\n  RuntimeChecks,\n  select,\n  Store,\n} from '@ngrx/store';\nimport { withLatestFrom } from 'rxjs/operators';\nimport {\n  ROUTER_CANCEL,\n  ROUTER_ERROR,\n  ROUTER_NAVIGATED,\n  ROUTER_NAVIGATION,\n  ROUTER_REQUEST,\n} from './actions';\nimport {\n  NavigationActionTiming,\n  ROUTER_CONFIG,\n  RouterState,\n  StateKeyOrSelector,\n  StoreRouterConfig,\n} from './router_store_config';\nimport {\n  FullRouterStateSerializer,\n  SerializedRouterStateSnapshot,\n} from './serializers/full_serializer';\nimport { RouterReducerState } from './reducer';\nimport { RouterStateSerializer } from './serializers/base';\n\nenum RouterTrigger {\n  NONE = 1,\n  ROUTER = 2,\n  STORE = 3,\n}\n\ninterface StoreRouterActionPayload {\n  event: RouterEvent;\n  routerState?: SerializedRouterStateSnapshot;\n  storeState?: any;\n}\n\n/**\n * Shared router initialization logic used alongside both the StoreRouterConnectingModule and the provideRouterStore\n * function\n */\n@Injectable()\nexport class StoreRouterConnectingService {\n  private lastEvent: Event | null = null;\n  private routerState: SerializedRouterStateSnapshot | null = null;\n  private storeState: any;\n  private trigger = RouterTrigger.NONE;\n  private readonly stateKey: StateKeyOrSelector;\n\n  constructor(\n    private store: Store<any>,\n    private router: Router,\n    private serializer: RouterStateSerializer<SerializedRouterStateSnapshot>,\n    private errorHandler: ErrorHandler,\n    @Inject(ROUTER_CONFIG) private readonly config: StoreRouterConfig,\n    @Inject(ACTIVE_RUNTIME_CHECKS)\n    private readonly activeRuntimeChecks: RuntimeChecks\n  ) {\n    this.stateKey = this.config.stateKey as StateKeyOrSelector;\n\n    if (\n      !isNgrxMockEnvironment() &&\n      isDevMode() &&\n      (activeRuntimeChecks?.strictActionSerializability ||\n        activeRuntimeChecks?.strictStateSerializability) &&\n      this.serializer instanceof FullRouterStateSerializer\n    ) {\n      console.warn(\n        '@ngrx/router-store: The serializability runtime checks cannot be enabled ' +\n          'with the FullRouterStateSerializer. The FullRouterStateSerializer ' +\n          'has an unserializable router state and actions that are not serializable. ' +\n          'To use the serializability runtime checks either use ' +\n          'the MinimalRouterStateSerializer or implement a custom router state serializer.'\n      );\n    }\n\n    this.setUpStoreStateListener();\n    this.setUpRouterEventsListener();\n  }\n\n  private setUpStoreStateListener(): void {\n    this.store\n      .pipe(select(this.stateKey as any), withLatestFrom(this.store))\n      .subscribe(([routerStoreState, storeState]) => {\n        this.navigateIfNeeded(routerStoreState, storeState);\n      });\n  }\n\n  private navigateIfNeeded(\n    routerStoreState: RouterReducerState,\n    storeState: any\n  ): void {\n    if (!routerStoreState || !routerStoreState.state) {\n      return;\n    }\n    if (this.trigger === RouterTrigger.ROUTER) {\n      return;\n    }\n    if (this.lastEvent instanceof NavigationStart) {\n      return;\n    }\n\n    const url = routerStoreState.state.url;\n    if (!isSameUrl(this.router.url, url)) {\n      this.storeState = storeState;\n      this.trigger = RouterTrigger.STORE;\n      this.router.navigateByUrl(url).catch((error) => {\n        this.errorHandler.handleError(error);\n      });\n    }\n  }\n\n  private setUpRouterEventsListener(): void {\n    const dispatchNavLate =\n      this.config.navigationActionTiming ===\n      NavigationActionTiming.PostActivation;\n    let routesRecognized: RoutesRecognized;\n\n    this.router.events\n      .pipe(withLatestFrom(this.store))\n      .subscribe(([event, storeState]) => {\n        this.lastEvent = event;\n\n        if (event instanceof NavigationStart) {\n          this.routerState = this.serializer.serialize(\n            this.router.routerState.snapshot\n          );\n          if (this.trigger !== RouterTrigger.STORE) {\n            this.storeState = storeState;\n            this.dispatchRouterRequest(event);\n          }\n        } else if (event instanceof RoutesRecognized) {\n          routesRecognized = event;\n\n          if (!dispatchNavLate && this.trigger !== RouterTrigger.STORE) {\n            this.dispatchRouterNavigation(event);\n          }\n        } else if (event instanceof NavigationCancel) {\n          this.dispatchRouterCancel(event);\n          this.reset();\n        } else if (event instanceof NavigationError) {\n          this.dispatchRouterError(event);\n          this.reset();\n        } else if (event instanceof NavigationEnd) {\n          if (this.trigger !== RouterTrigger.STORE) {\n            if (dispatchNavLate) {\n              this.dispatchRouterNavigation(routesRecognized);\n            }\n            this.dispatchRouterNavigated(event);\n          }\n          this.reset();\n        }\n      });\n  }\n\n  private dispatchRouterRequest(event: NavigationStart): void {\n    this.dispatchRouterAction(ROUTER_REQUEST, { event });\n  }\n\n  private dispatchRouterNavigation(\n    lastRoutesRecognized: RoutesRecognized\n  ): void {\n    const nextRouterState = this.serializer.serialize(\n      lastRoutesRecognized.state\n    );\n    this.dispatchRouterAction(ROUTER_NAVIGATION, {\n      routerState: nextRouterState,\n      event: new RoutesRecognized(\n        lastRoutesRecognized.id,\n        lastRoutesRecognized.url,\n        lastRoutesRecognized.urlAfterRedirects,\n        nextRouterState\n      ),\n    });\n  }\n\n  private dispatchRouterCancel(event: NavigationCancel): void {\n    this.dispatchRouterAction(ROUTER_CANCEL, {\n      storeState: this.storeState,\n      event,\n    });\n  }\n\n  private dispatchRouterError(event: NavigationError): void {\n    this.dispatchRouterAction(ROUTER_ERROR, {\n      storeState: this.storeState,\n      event: new NavigationError(event.id, event.url, `${event}`),\n    });\n  }\n\n  private dispatchRouterNavigated(event: NavigationEnd): void {\n    const routerState = this.serializer.serialize(\n      this.router.routerState.snapshot\n    );\n    this.dispatchRouterAction(ROUTER_NAVIGATED, { event, routerState });\n  }\n\n  private dispatchRouterAction(\n    type: string,\n    payload: StoreRouterActionPayload\n  ): void {\n    this.trigger = RouterTrigger.ROUTER;\n    try {\n      this.store.dispatch({\n        type,\n        payload: {\n          routerState: this.routerState,\n          ...payload,\n          event:\n            this.config.routerState === RouterState.Full\n              ? payload.event\n              : {\n                  id: payload.event.id,\n                  url: payload.event.url,\n                  // safe, as it will just be `undefined` for non-NavigationEnd router events\n                  urlAfterRedirects: (payload.event as NavigationEnd)\n                    .urlAfterRedirects,\n                },\n        },\n      });\n    } finally {\n      this.trigger = RouterTrigger.NONE;\n    }\n  }\n\n  private reset() {\n    this.trigger = RouterTrigger.NONE;\n    this.storeState = null;\n    this.routerState = null;\n  }\n}\n\n/**\n * Check if the URLs are matching. Accounts for the possibility of trailing \"/\" in url.\n */\nfunction isSameUrl(first: string, second: string): boolean {\n  return stripTrailingSlash(first) === stripTrailingSlash(second);\n}\n\nfunction stripTrailingSlash(text: string): string {\n  if (text?.length > 0 && text[text.length - 1] === '/') {\n    return text.substring(0, text.length - 1);\n  }\n  return text;\n}\n", "import {\n  ENVIRONMENT_INITIALIZER,\n  EnvironmentProviders,\n  inject,\n  makeEnvironmentProviders,\n} from '@angular/core';\nimport {\n  _createRouterConfig,\n  _ROUTER_CONFIG,\n  ROUTER_CONFIG,\n  RouterState,\n  StoreRouterConfig,\n} from './router_store_config';\nimport {\n  FullRouterStateSerializer,\n  SerializedRouterStateSnapshot,\n} from './serializers/full_serializer';\nimport { MinimalRouterStateSerializer } from './serializers/minimal_serializer';\nimport {\n  BaseRouterStoreState,\n  RouterStateSerializer,\n} from './serializers/base';\nimport { StoreRouterConnectingService } from './store_router_connecting.service';\n\n/**\n * Connects the Angular Router to the Store.\n *\n * @usageNotes\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideStore({ router: routerReducer }),\n *     provideRouterStore(),\n *   ],\n * });\n * ```\n */\nexport function provideRouterStore<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n>(config: StoreRouterConfig<T> = {}): EnvironmentProviders {\n  return makeEnvironmentProviders([\n    { provide: _ROUTER_CONFIG, useValue: config },\n    {\n      provide: ROUTER_CONFIG,\n      useFactory: _createRouterConfig,\n      deps: [_ROUTER_CONFIG],\n    },\n    {\n      provide: RouterStateSerializer,\n      useClass: config.serializer\n        ? config.serializer\n        : config.routerState === RouterState.Full\n        ? FullRouterStateSerializer\n        : MinimalRouterStateSerializer,\n    },\n    {\n      provide: ENVIRONMENT_INITIALIZER,\n      multi: true,\n      useFactory() {\n        return () => inject(StoreRouterConnectingService);\n      },\n    },\n    StoreRouterConnectingService,\n  ]);\n}\n", "import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { BaseRouterStoreState } from './serializers/base';\nimport { SerializedRouterStateSnapshot } from './serializers/full_serializer';\nimport { StoreRouterConfig } from './router_store_config';\nimport { provideRouterStore } from './provide_router_store';\n\n/**\n * Connects RouterModule with StoreModule.\n *\n * During the navigation, before any guards or resolvers run, the router will dispatch\n * a ROUTER_NAVIGATION action, which has the following signature:\n *\n * ```\n * export type RouterNavigationPayload = {\n *   routerState: SerializedRouterStateSnapshot,\n *   event: RoutesRecognized\n * }\n * ```\n *\n * Either a reducer or an effect can be invoked in response to this action.\n * If the invoked reducer throws, the navigation will be canceled.\n *\n * If navigation gets canceled because of a guard, a ROUTER_CANCEL action will be\n * dispatched. If navigation results in an error, a ROUTER_ERROR action will be dispatched.\n *\n * Both ROUTER_CANCEL and ROUTER_ERROR contain the store state before the navigation\n * which can be used to restore the consistency of the store.\n *\n * Usage:\n *\n * ```typescript\n * @NgModule({\n *   declarations: [AppCmp, SimpleCmp],\n *   imports: [\n *     BrowserModule,\n *     StoreModule.forRoot(mapOfReducers),\n *     RouterModule.forRoot([\n *       { path: '', component: SimpleCmp },\n *       { path: 'next', component: SimpleCmp }\n *     ]),\n *     StoreRouterConnectingModule.forRoot()\n *   ],\n *   bootstrap: [AppCmp]\n * })\n * export class AppModule {\n * }\n * ```\n */\n@NgModule({})\nexport class StoreRouterConnectingModule {\n  static forRoot<\n    T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n  >(\n    config: StoreRouterConfig<T> = {}\n  ): ModuleWithProviders<StoreRouterConnectingModule> {\n    return {\n      ngModule: StoreRouterConnectingModule,\n      providers: [provideRouterStore(config)],\n    };\n  }\n}\n", "import {\n  createFeatureSelector,\n  createSelector,\n  MemoizedSelector,\n} from '@ngrx/store';\nimport { RouterStateSelectors } from './models';\nimport { RouterReducerState } from './reducer';\nimport { DEFAULT_ROUTER_FEATURENAME } from './router_store_config';\n\nexport function createRouterSelector<\n  State extends Record<string, any>\n>(): MemoizedSelector<State, RouterReducerState> {\n  return createFeatureSelector(DEFAULT_ROUTER_FEATURENAME);\n}\n\nexport function getRouterSelectors<V extends Record<string, any>>(\n  selectState: (state: V) => RouterReducerState<any> = createRouterSelector<V>()\n): RouterStateSelectors<V> {\n  const selectRouterState = createSelector(\n    selectState,\n    (router) => router && router.state\n  );\n  const selectRootRoute = createSelector(\n    selectRouterState,\n    (routerState) => routerState && routerState.root\n  );\n  const selectCurrentRoute = createSelector(selectRootRoute, (rootRoute) => {\n    if (!rootRoute) {\n      return undefined;\n    }\n    let route = rootRoute;\n    while (route.firstChild) {\n      route = route.firstChild;\n    }\n    return route;\n  });\n  const selectFragment = createSelector(\n    selectRootRoute,\n    (route) => route && route.fragment\n  );\n  const selectQueryParams = createSelector(\n    selectRootRoute,\n    (route) => route && route.queryParams\n  );\n  const selectQueryParam = (param: string) =>\n    createSelector(selectQueryParams, (params) => params && params[param]);\n  const selectRouteParams = createSelector(\n    selectCurrentRoute,\n    (route) => route && route.params\n  );\n  const selectRouteParam = (param: string) =>\n    createSelector(selectRouteParams, (params) => params && params[param]);\n  const selectRouteData = createSelector(\n    selectCurrentRoute,\n    (route) => route && route.data\n  );\n  const selectRouteDataParam = (param: string) =>\n    createSelector(selectRouteData, (data) => data && data[param]);\n  const selectUrl = createSelector(\n    selectRouterState,\n    (routerState) => routerState && routerState.url\n  );\n  const selectTitle = createSelector(selectCurrentRoute, (route) => {\n    if (!route?.routeConfig) {\n      return undefined;\n    }\n    return typeof route.routeConfig.title === 'string'\n      ? route.routeConfig.title // static title\n      : route.title; // resolved title\n  });\n\n  return {\n    selectCurrentRoute,\n    selectFragment,\n    selectQueryParams,\n    selectQueryParam,\n    selectRouteParams,\n    selectRouteParam,\n    selectRouteData,\n    selectRouteDataParam,\n    selectUrl,\n    selectTitle,\n  };\n}\n"],
  "mappings": "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",
  "names": ["NavigationActionTiming", "RouterTrigger"]
}
