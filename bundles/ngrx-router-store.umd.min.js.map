{"version":3,"sources":["ng://@ngrx/router-store/src/actions.ts","ng://@ngrx/router-store/src/serializers/base.ts","ng://@ngrx/router-store/src/serializers/default_serializer.ts","ng://@ngrx/router-store/src/serializers/minimal_serializer.ts","ng://@ngrx/router-store/src/router_store_module.ts","ng://@ngrx/router-store/src/router_selectors.ts","ng://@ngrx/router-store/src/reducer.ts"],"names":["routerRequestAction","createAction","props","ROUTER_NAVIGATION","routerNavigationAction","ROUTER_CANCEL","routerCancelAction","ROUTER_ERROR","routerErrorAction","routerNavigatedAction","DefaultRouterStateSerializer","prototype","serialize","routerState","root","this","serializeRoute","url","route","_this","children","map","c","params","paramMap","data","outlet","routeConfig","component","path","pathMatch","redirectTo","queryParams","queryParamMap","fragment","undefined","parent","firstChild","pathFromRoot","MinimalRouterStateSerializer","NavigationActionTiming","PreActivation","PostActivation","_ROUTER_CONFIG","InjectionToken","ROUTER_CONFIG","_createRouterConfig","config","__assign","stateKey","serializer","navigationActionTiming","RouterTrigger","NONE","ROUTER","STORE","StoreRouterConnectingModule","store","router","errorHandler","lastEvent","trigger","setUpStoreStateListener","setUpRouterEventsListener","forRoot","ngModule","providers","provide","useValue","useFactory","deps","RouterStateSerializer","useClass","pipe","select","withLatestFrom","subscribe","_a","_b","__read","routerStoreState","storeState","navigateIfNeeded","state","NavigationStart","navigateByUrl","catch","error","handleError","routesRecognized","dispatchNavLate","events","event","snapshot","dispatchRouterRequest","RoutesRecognized","dispatchRouterNavigation","NavigationCancel","dispatchRouterCancel","reset","NavigationError","dispatchRouterError","NavigationEnd","dispatchRouterNavigated","dispatchRouterAction","lastRoutesRecognized","nextRouterState","id","urlAfterRedirects","type","payload","dispatch","NgModule","args","Store","Router","ErrorHandler","Inject","selectState","selectRouterState","createSelector","selectCurrentRoute","selectFragment","selectQueryParams","selectRouteParams","selectRouteData","selectUrl","selectQueryParam","param","selectRouteParam","action","routerAction","navigationId"],"mappings":"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","sourcesContent":["import {\n  NavigationCancel,\n  NavigationEnd,\n  NavigationError,\n  NavigationStart,\n  RoutesRecognized,\n} from '@angular/router';\n\nimport { BaseRouterStoreState } from './serializers/base';\nimport { SerializedRouterStateSnapshot } from './serializers/default_serializer';\nimport { createAction, props } from '@ngrx/store';\n\n/**\n * An action dispatched when a router navigation request is fired.\n */\nexport const ROUTER_REQUEST = '@ngrx/router-store/request';\n\n/**\n * Payload of ROUTER_REQUEST\n */\nexport type RouterRequestPayload<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: T;\n  event: NavigationStart;\n};\n\n/**\n * An action dispatched when a router navigation request is fired.\n */\nexport type RouterRequestAction<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_REQUEST;\n  payload: RouterRequestPayload<T>;\n};\n\nexport const routerRequestAction = createAction(\n  ROUTER_REQUEST,\n  props<{ payload: RouterRequestPayload<SerializedRouterStateSnapshot> }>()\n);\n/**\n * An action dispatched when the router navigates.\n */\nexport const ROUTER_NAVIGATION = '@ngrx/router-store/navigation';\n\n/**\n * Payload of ROUTER_NAVIGATION.\n */\nexport type RouterNavigationPayload<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: T;\n  event: RoutesRecognized;\n};\n\n/**\n * An action dispatched when the router navigates.\n */\nexport type RouterNavigationAction<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_NAVIGATION;\n  payload: RouterNavigationPayload<T>;\n};\n\nexport const routerNavigationAction = createAction(\n  ROUTER_NAVIGATION,\n  props<{ payload: RouterNavigationPayload<SerializedRouterStateSnapshot> }>()\n);\n\n/**\n * An action dispatched when the router cancels navigation.\n */\nexport const ROUTER_CANCEL = '@ngrx/router-store/cancel';\n\n/**\n * Payload of ROUTER_CANCEL.\n */\nexport type RouterCancelPayload<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: V;\n  storeState: T;\n  event: NavigationCancel;\n};\n\n/**\n * An action dispatched when the router cancels navigation.\n */\nexport type RouterCancelAction<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_CANCEL;\n  payload: RouterCancelPayload<T, V>;\n};\n\nexport const routerCancelAction = createAction(\n  ROUTER_CANCEL,\n  props<{ payload: RouterCancelPayload<SerializedRouterStateSnapshot> }>()\n);\n\n/**\n * An action dispatched when the router errors.\n */\nexport const ROUTER_ERROR = '@ngrx/router-store/error';\n\n/**\n * Payload of ROUTER_ERROR.\n */\nexport type RouterErrorPayload<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: V;\n  storeState: T;\n  event: NavigationError;\n};\n\n/**\n * An action dispatched when the router errors.\n */\nexport type RouterErrorAction<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_ERROR;\n  payload: RouterErrorPayload<T, V>;\n};\n\nexport const routerErrorAction = createAction(\n  ROUTER_ERROR,\n  props<{ payload: RouterErrorPayload<SerializedRouterStateSnapshot> }>()\n);\n\n/**\n * An action dispatched after navigation has ended and new route is active.\n */\nexport const ROUTER_NAVIGATED = '@ngrx/router-store/navigated';\n\n/**\n * Payload of ROUTER_NAVIGATED.\n */\nexport type RouterNavigatedPayload<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  routerState: T;\n  event: NavigationEnd;\n};\n\n/**\n * An action dispatched after navigation has ended and new route is active.\n */\nexport type RouterNavigatedAction<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  type: typeof ROUTER_NAVIGATED;\n  payload: RouterNavigatedPayload<T>;\n};\n\nexport const routerNavigatedAction = createAction(\n  ROUTER_NAVIGATED,\n  props<{ payload: RouterNavigatedPayload<SerializedRouterStateSnapshot> }>()\n);\n\n/**\n * A union type of router actions.\n */\nexport type RouterAction<\n  T,\n  V extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> =\n  | RouterRequestAction<V>\n  | RouterNavigationAction<V>\n  | RouterCancelAction<T, V>\n  | RouterErrorAction<T, V>\n  | RouterNavigatedAction<V>;\n","import { RouterStateSnapshot } from '@angular/router';\n\n/**\n * Simple router state.\n * All custom router states / state serializers should have at least\n * the properties of this interface.\n */\nexport interface BaseRouterStoreState {\n  url: string;\n}\n\nexport abstract class RouterStateSerializer<\n  T extends BaseRouterStoreState = BaseRouterStoreState\n> {\n  abstract serialize(routerState: RouterStateSnapshot): T;\n}\n","import { ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\nimport { BaseRouterStoreState, RouterStateSerializer } from './base';\n\nexport interface SerializedRouterStateSnapshot extends BaseRouterStoreState {\n  root: ActivatedRouteSnapshot;\n  url: string;\n}\n\nexport class DefaultRouterStateSerializer\n  implements RouterStateSerializer<SerializedRouterStateSnapshot> {\n  serialize(routerState: RouterStateSnapshot): SerializedRouterStateSnapshot {\n    return {\n      root: this.serializeRoute(routerState.root),\n      url: routerState.url,\n    };\n  }\n\n  private serializeRoute(\n    route: ActivatedRouteSnapshot\n  ): ActivatedRouteSnapshot {\n    const children = route.children.map(c => this.serializeRoute(c));\n    return {\n      params: route.params,\n      paramMap: route.paramMap,\n      data: route.data,\n      url: route.url,\n      outlet: route.outlet,\n      routeConfig: route.routeConfig\n        ? {\n            component: route.routeConfig.component,\n            path: route.routeConfig.path,\n            pathMatch: route.routeConfig.pathMatch,\n            redirectTo: route.routeConfig.redirectTo,\n            outlet: route.routeConfig.outlet,\n          }\n        : null,\n      queryParams: route.queryParams,\n      queryParamMap: route.queryParamMap,\n      fragment: route.fragment,\n      component: (route.routeConfig\n        ? route.routeConfig.component\n        : undefined) as any,\n      root: undefined as any,\n      parent: undefined as any,\n      firstChild: children[0],\n      pathFromRoot: undefined as any,\n      children,\n    };\n  }\n}\n","import { RouterStateSnapshot, ActivatedRouteSnapshot } from '@angular/router';\nimport { BaseRouterStoreState, RouterStateSerializer } from './base';\n\nexport interface MinimalActivatedRouteSnapshot {\n  routeConfig: ActivatedRouteSnapshot['routeConfig'];\n  url: ActivatedRouteSnapshot['url'];\n  params: ActivatedRouteSnapshot['params'];\n  queryParams: ActivatedRouteSnapshot['queryParams'];\n  fragment: ActivatedRouteSnapshot['fragment'];\n  data: ActivatedRouteSnapshot['data'];\n  outlet: ActivatedRouteSnapshot['outlet'];\n  firstChild?: MinimalActivatedRouteSnapshot;\n  children: MinimalActivatedRouteSnapshot[];\n}\n\nexport interface MinimalRouterStateSnapshot extends BaseRouterStoreState {\n  root: MinimalActivatedRouteSnapshot;\n  url: string;\n}\n\nexport class MinimalRouterStateSerializer\n  implements RouterStateSerializer<MinimalRouterStateSnapshot> {\n  serialize(routerState: RouterStateSnapshot): MinimalRouterStateSnapshot {\n    return {\n      root: this.serializeRoute(routerState.root),\n      url: routerState.url,\n    };\n  }\n\n  private serializeRoute(\n    route: ActivatedRouteSnapshot\n  ): MinimalActivatedRouteSnapshot {\n    const children = route.children.map(c => this.serializeRoute(c));\n    return {\n      params: route.params,\n      data: route.data,\n      url: route.url,\n      outlet: route.outlet,\n      routeConfig: route.routeConfig\n        ? {\n            path: route.routeConfig.path,\n            pathMatch: route.routeConfig.pathMatch,\n            redirectTo: route.routeConfig.redirectTo,\n            outlet: route.routeConfig.outlet,\n          }\n        : null,\n      queryParams: route.queryParams,\n      fragment: route.fragment,\n      firstChild: children[0],\n      children,\n    };\n  }\n}\n","import {\n  Inject,\n  InjectionToken,\n  ModuleWithProviders,\n  NgModule,\n  ErrorHandler,\n} from '@angular/core';\nimport {\n  NavigationCancel,\n  NavigationError,\n  NavigationEnd,\n  Router,\n  RoutesRecognized,\n  NavigationStart,\n  Event,\n  RouterEvent,\n} from '@angular/router';\nimport { select, Selector, Store } from '@ngrx/store';\nimport { withLatestFrom } from 'rxjs/operators';\n\nimport {\n  ROUTER_CANCEL,\n  ROUTER_ERROR,\n  ROUTER_NAVIGATED,\n  ROUTER_NAVIGATION,\n  ROUTER_REQUEST,\n} from './actions';\nimport { RouterReducerState } from './reducer';\nimport {\n  RouterStateSerializer,\n  BaseRouterStoreState,\n} from './serializers/base';\nimport {\n  DefaultRouterStateSerializer,\n  SerializedRouterStateSnapshot,\n} from './serializers/default_serializer';\nimport { MinimalRouterStateSerializer } from './serializers/minimal_serializer';\n\nexport type StateKeyOrSelector<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = string | Selector<any, RouterReducerState<T>>;\n\n/**\n * Full = Serializes the router event with DefaultRouterStateSerializer\n * Minimal = Serializes the router event with MinimalRouterStateSerializer\n */\nexport const enum RouterState {\n  Full,\n  Minimal,\n}\n\nexport interface StoreRouterConfig<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> {\n  stateKey?: StateKeyOrSelector<T>;\n  serializer?: new (...args: any[]) => RouterStateSerializer;\n  /**\n   * By default, ROUTER_NAVIGATION is dispatched before guards and resolvers run.\n   * Therefore, the action could run too soon, for example\n   * there may be a navigation cancel due to a guard saying the navigation is not allowed.\n   * To run ROUTER_NAVIGATION after guards and resolvers,\n   * set this property to NavigationActionTiming.PostActivation.\n   */\n  navigationActionTiming?: NavigationActionTiming;\n  /**\n   * Decides which router serializer should be used, if there is none provided, and the metadata on the dispatched @ngrx/router-store action payload.\n   * Set to `Full` to use the `DefaultRouterStateSerializer` and to set the angular router events as payload.\n   * Set to `Minimal` to use the `MinimalRouterStateSerializer` and to set a minimal router event with the navigation id and url as payload.\n   */\n  routerState?: RouterState;\n}\n\ninterface StoreRouterActionPayload {\n  event: RouterEvent;\n  routerState?: SerializedRouterStateSnapshot;\n  storeState?: any;\n}\n\nexport enum NavigationActionTiming {\n  PreActivation = 1,\n  PostActivation = 2,\n}\n\nexport const _ROUTER_CONFIG = new InjectionToken(\n  '@ngrx/router-store Internal Configuration'\n);\nexport const ROUTER_CONFIG = new InjectionToken(\n  '@ngrx/router-store Configuration'\n);\nexport const DEFAULT_ROUTER_FEATURENAME = 'router';\n\nexport function _createRouterConfig(\n  config: StoreRouterConfig\n): StoreRouterConfig {\n  return {\n    stateKey: DEFAULT_ROUTER_FEATURENAME,\n    serializer: MinimalRouterStateSerializer,\n    navigationActionTiming: NavigationActionTiming.PreActivation,\n    ...config,\n  };\n}\n\nenum RouterTrigger {\n  NONE = 1,\n  ROUTER = 2,\n  STORE = 3,\n}\n\n/**\n * Connects RouterModule with StoreModule.\n *\n * During the navigation, before any guards or resolvers run, the router will dispatch\n * a ROUTER_NAVIGATION action, which has the following signature:\n *\n * ```\n * export type RouterNavigationPayload = {\n *   routerState: SerializedRouterStateSnapshot,\n *   event: RoutesRecognized\n * }\n * ```\n *\n * Either a reducer or an effect can be invoked in response to this action.\n * If the invoked reducer throws, the navigation will be canceled.\n *\n * If navigation gets canceled because of a guard, a ROUTER_CANCEL action will be\n * dispatched. If navigation results in an error, a ROUTER_ERROR action will be dispatched.\n *\n * Both ROUTER_CANCEL and ROUTER_ERROR contain the store state before the navigation\n * which can be used to restore the consistency of the store.\n *\n * Usage:\n *\n * ```typescript\n * @NgModule({\n *   declarations: [AppCmp, SimpleCmp],\n *   imports: [\n *     BrowserModule,\n *     StoreModule.forRoot(mapOfReducers),\n *     RouterModule.forRoot([\n *       { path: '', component: SimpleCmp },\n *       { path: 'next', component: SimpleCmp }\n *     ]),\n *     StoreRouterConnectingModule.forRoot()\n *   ],\n *   bootstrap: [AppCmp]\n * })\n * export class AppModule {\n * }\n * ```\n */\n@NgModule({})\nexport class StoreRouterConnectingModule {\n  static forRoot<\n    T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n  >(\n    config: StoreRouterConfig<T> = {}\n  ): ModuleWithProviders<StoreRouterConnectingModule> {\n    return {\n      ngModule: StoreRouterConnectingModule,\n      providers: [\n        { provide: _ROUTER_CONFIG, useValue: config },\n        {\n          provide: ROUTER_CONFIG,\n          useFactory: _createRouterConfig,\n          deps: [_ROUTER_CONFIG],\n        },\n        {\n          provide: RouterStateSerializer,\n          useClass: config.serializer\n            ? config.serializer\n            : config.routerState === RouterState.Full\n              ? DefaultRouterStateSerializer\n              : MinimalRouterStateSerializer,\n        },\n      ],\n    };\n  }\n\n  private lastEvent: Event | null = null;\n  private routerState: SerializedRouterStateSnapshot | null = null;\n  private storeState: any;\n  private trigger = RouterTrigger.NONE;\n\n  private stateKey: StateKeyOrSelector;\n\n  constructor(\n    private store: Store<any>,\n    private router: Router,\n    private serializer: RouterStateSerializer<SerializedRouterStateSnapshot>,\n    private errorHandler: ErrorHandler,\n    @Inject(ROUTER_CONFIG) private config: StoreRouterConfig\n  ) {\n    this.stateKey = this.config.stateKey as StateKeyOrSelector;\n\n    this.setUpStoreStateListener();\n    this.setUpRouterEventsListener();\n  }\n\n  private setUpStoreStateListener(): void {\n    this.store\n      .pipe(\n        select(this.stateKey as any),\n        withLatestFrom(this.store)\n      )\n      .subscribe(([routerStoreState, storeState]) => {\n        this.navigateIfNeeded(routerStoreState, storeState);\n      });\n  }\n\n  private navigateIfNeeded(\n    routerStoreState: RouterReducerState,\n    storeState: any\n  ): void {\n    if (!routerStoreState || !routerStoreState.state) {\n      return;\n    }\n    if (this.trigger === RouterTrigger.ROUTER) {\n      return;\n    }\n    if (this.lastEvent instanceof NavigationStart) {\n      return;\n    }\n\n    const url = routerStoreState.state.url;\n    if (this.router.url !== url) {\n      this.storeState = storeState;\n      this.trigger = RouterTrigger.STORE;\n      this.router.navigateByUrl(url).catch(error => {\n        this.errorHandler.handleError(error);\n      });\n    }\n  }\n\n  private setUpRouterEventsListener(): void {\n    const dispatchNavLate =\n      this.config.navigationActionTiming ===\n      NavigationActionTiming.PostActivation;\n    let routesRecognized: RoutesRecognized;\n\n    this.router.events\n      .pipe(withLatestFrom(this.store))\n      .subscribe(([event, storeState]) => {\n        this.lastEvent = event;\n\n        if (event instanceof NavigationStart) {\n          this.routerState = this.serializer.serialize(\n            this.router.routerState.snapshot\n          );\n          if (this.trigger !== RouterTrigger.STORE) {\n            this.storeState = storeState;\n            this.dispatchRouterRequest(event);\n          }\n        } else if (event instanceof RoutesRecognized) {\n          routesRecognized = event;\n\n          if (!dispatchNavLate && this.trigger !== RouterTrigger.STORE) {\n            this.dispatchRouterNavigation(event);\n          }\n        } else if (event instanceof NavigationCancel) {\n          this.dispatchRouterCancel(event);\n          this.reset();\n        } else if (event instanceof NavigationError) {\n          this.dispatchRouterError(event);\n          this.reset();\n        } else if (event instanceof NavigationEnd) {\n          if (this.trigger !== RouterTrigger.STORE) {\n            if (dispatchNavLate) {\n              this.dispatchRouterNavigation(routesRecognized);\n            }\n            this.dispatchRouterNavigated(event);\n          }\n          this.reset();\n        }\n      });\n  }\n\n  private dispatchRouterRequest(event: NavigationStart): void {\n    this.dispatchRouterAction(ROUTER_REQUEST, { event });\n  }\n\n  private dispatchRouterNavigation(\n    lastRoutesRecognized: RoutesRecognized\n  ): void {\n    const nextRouterState = this.serializer.serialize(\n      lastRoutesRecognized.state\n    );\n    this.dispatchRouterAction(ROUTER_NAVIGATION, {\n      routerState: nextRouterState,\n      event: new RoutesRecognized(\n        lastRoutesRecognized.id,\n        lastRoutesRecognized.url,\n        lastRoutesRecognized.urlAfterRedirects,\n        nextRouterState\n      ),\n    });\n  }\n\n  private dispatchRouterCancel(event: NavigationCancel): void {\n    this.dispatchRouterAction(ROUTER_CANCEL, {\n      storeState: this.storeState,\n      event,\n    });\n  }\n\n  private dispatchRouterError(event: NavigationError): void {\n    this.dispatchRouterAction(ROUTER_ERROR, {\n      storeState: this.storeState,\n      event: new NavigationError(event.id, event.url, `${event}`),\n    });\n  }\n\n  private dispatchRouterNavigated(event: NavigationEnd): void {\n    const routerState = this.serializer.serialize(\n      this.router.routerState.snapshot\n    );\n    this.dispatchRouterAction(ROUTER_NAVIGATED, { event, routerState });\n  }\n\n  private dispatchRouterAction(\n    type: string,\n    payload: StoreRouterActionPayload\n  ): void {\n    this.trigger = RouterTrigger.ROUTER;\n    try {\n      this.store.dispatch({\n        type,\n        payload: {\n          routerState: this.routerState,\n          ...payload,\n          event:\n            this.config.routerState === RouterState.Full\n              ? payload.event\n              : { id: payload.event.id, url: payload.event.url },\n        },\n      });\n    } finally {\n      this.trigger = RouterTrigger.NONE;\n    }\n  }\n\n  private reset() {\n    this.trigger = RouterTrigger.NONE;\n    this.storeState = null;\n    this.routerState = null;\n  }\n}\n","import { createSelector } from '@ngrx/store';\nimport { RouterStateSelectors } from './models';\nimport { RouterReducerState } from './reducer';\n\nexport function getSelectors<V>(\n  selectState: (state: V) => RouterReducerState<any>\n): RouterStateSelectors<V>;\nexport function getSelectors<V>(\n  selectState: (state: V) => RouterReducerState<any>\n): RouterStateSelectors<V> {\n  const selectRouterState = createSelector(\n    selectState,\n    router => router && router.state\n  );\n  const selectCurrentRoute = createSelector(selectRouterState, routerState => {\n    if (!routerState) {\n      return undefined;\n    }\n    let route = routerState.root;\n    while (route.firstChild) {\n      route = route.firstChild;\n    }\n    return route;\n  });\n  const selectFragment = createSelector(\n    selectCurrentRoute,\n    route => route && route.fragment\n  );\n  const selectQueryParams = createSelector(\n    selectCurrentRoute,\n    route => route && route.queryParams\n  );\n  const selectQueryParam = (param: string) =>\n    createSelector(selectQueryParams, params => params && params[param]);\n  const selectRouteParams = createSelector(\n    selectCurrentRoute,\n    route => route && route.params\n  );\n  const selectRouteParam = (param: string) =>\n    createSelector(selectRouteParams, params => params && params[param]);\n  const selectRouteData = createSelector(\n    selectCurrentRoute,\n    route => route && route.data\n  );\n  const selectUrl = createSelector(\n    selectRouterState,\n    routerState => routerState && routerState.url\n  );\n\n  return {\n    selectCurrentRoute,\n    selectFragment,\n    selectQueryParams,\n    selectQueryParam,\n    selectRouteParams,\n    selectRouteParam,\n    selectRouteData,\n    selectUrl,\n  };\n}\n","import { Action } from '@ngrx/store';\nimport {\n  ROUTER_CANCEL,\n  ROUTER_ERROR,\n  ROUTER_NAVIGATION,\n  RouterAction,\n} from './actions';\nimport { BaseRouterStoreState } from './serializers/base';\nimport { SerializedRouterStateSnapshot } from './serializers/default_serializer';\n\nexport type RouterReducerState<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n> = {\n  state: T;\n  navigationId: number;\n};\n\nexport function routerReducer<\n  T extends BaseRouterStoreState = SerializedRouterStateSnapshot\n>(\n  state: RouterReducerState<T> | undefined,\n  action: Action\n): RouterReducerState<T> {\n  // Allow compilation with strictFunctionTypes - ref: #1344\n  const routerAction = action as RouterAction<any, T>;\n  switch (routerAction.type) {\n    case ROUTER_NAVIGATION:\n    case ROUTER_ERROR:\n    case ROUTER_CANCEL:\n      return {\n        state: routerAction.payload.routerState,\n        navigationId: routerAction.payload.event.id,\n      };\n    default:\n      return state as RouterReducerState<T>;\n  }\n}\n"]}